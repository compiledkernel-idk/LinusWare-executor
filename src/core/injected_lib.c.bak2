
/*
 * Filename: injected_lib.c
 *
 * Copyright (c) 2026 compiledkernel-idk
 * All Rights Reserved.
 *
 * This software is proprietary and confidential.
 * Unauthorized copying, distribution, or use of this file,
 * via any medium, is strictly prohibited.
 */

#define _GNU_SOURCE
#include "roblox_offsets.h"
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <link.h>
#include <pthread.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include "luau_api.h"

extern void heavy_simd_math(float *a, int b);
static void __attribute__((used)) keep_flex() {
  if (0)
    heavy_simd_math(0, 0);
}

#define LOG_PATH "/tmp/sirracha_debug.log"
#define IPC_READY_PATH "/tmp/sirracha_ready"
#define IPC_EXEC_PATH "/tmp/sirracha_exec.txt"
#define IPC_OUT_PATH "/tmp/sirracha_output.txt"
#define IPC_CMD_PATH "/tmp/sirracha_cmd.txt"

static volatile int g_running = 1;
static pthread_t g_worker_thread;
static FILE *g_log = NULL;

static luau_api_t g_api = {0};

static sigjmp_buf g_jmp;
static volatile int g_in_call = 0;

void log_debug(const char *fmt, ...) {
  if (!g_log) {
    g_log = fopen(LOG_PATH, "a");
    if (g_log)
      chmod(LOG_PATH, 0666);
  }
  if (g_log) {
    time_t now = time(NULL);
    struct tm *tm_info = localtime(&now);
    char timestamp[32];
    strftime(timestamp, sizeof(timestamp), "[%H:%M:%S] ", tm_info);
    fputs(timestamp, g_log);

    va_list args;
    va_start(args, fmt);
    vfprintf(g_log, fmt, args);
    va_end(args);
    fflush(g_log);
  }
}

static void write_ready_signal(void) {
  FILE *f = fopen(IPC_READY_PATH, "w");
  if (f) {
    fprintf(f, "SIRRACHA_V2\n");
    fprintf(f, "sober_base=0x%lx\n", g_api.sober_base);
    fprintf(f, "lua_state=%p\n", (void *)g_api.L);
    fprintf(f, "functions=%d\n", g_api.functions_resolved);
    fchmod(fileno(f), 0666);
    fclose(f);
    log_debug("Ready signal written to %s\n", IPC_READY_PATH);
  } else {
    log_debug("Failed to write ready signal: %s\n", strerror(errno));
  }
}

static void write_output(const char *fmt, ...) {
  FILE *out = fopen(IPC_OUT_PATH, "w");
  if (out) {
    chmod(IPC_OUT_PATH, 0666);
    va_list args;
    va_start(args, fmt);
    vfprintf(out, fmt, args);
    va_end(args);
    fclose(out);
  }
}

static char *read_script(void) {
  FILE *f = fopen(IPC_EXEC_PATH, "r");
  if (!f)
    return NULL;

  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  fseek(f, 0, SEEK_SET);

  if (fsize <= 0) {
    fclose(f);
    return NULL;
  }

  char *script = malloc(fsize + 1);
  if (!script) {
    fclose(f);
    return NULL;
  }

  size_t read_size = fread(script, 1, fsize, f);
  script[read_size] = '\0';

  // Trim trailing whitespace/newlines
  while (read_size > 0 &&
         (script[read_size - 1] == '\n' || script[read_size - 1] == '\r' ||
          script[read_size - 1] == ' ')) {
    script[read_size - 1] = '\0';
    read_size--;
  }

  fclose(f);
  unlink(IPC_EXEC_PATH);

  return script;
}

static void unlockbreaker(void) {
  pid_t my_pid = getpid();
  DIR *d = opendir("/proc");
  if (!d)
    return;

  struct dirent *e;
  while ((e = readdir(d))) {
    if (e->d_type != DT_DIR)
      continue;

    pid_t pid = atoi(e->d_name);
    if (pid <= 0 || pid == my_pid)
      continue;

    char status_path[256], line[256];
    snprintf(status_path, sizeof(status_path), "/proc/%d/status", pid);
    FILE *f = fopen(status_path, "r");
    if (!f)
      continue;

    int tracer = 0;
    while (fgets(line, sizeof(line), f)) {
      if (strncmp(line, "TracerPid:", 10) == 0) {
        tracer = atoi(line + 10);
        break;
      }
    }
    fclose(f);

    if (tracer == my_pid) {
      log_debug("Unlocking traced process %d\n", pid);
      ptrace(PTRACE_DETACH, pid, 0, 0);
    }
  }
  closedir(d);
}

uintptr_t find_sober_base(void) {
  FILE *maps = fopen("/proc/self/maps", "r");
  if (!maps)
    return 0;

  char line[512];
  uintptr_t base = 0;

  while (fgets(line, sizeof(line), maps)) {

    if ((strstr(line, "/sober") || strstr(line, "/app/bin/sober")) &&
        strstr(line, "r-xp")) {
      sscanf(line, "%lx", &base);
      log_debug("Found Sober base: 0x%lx\\n", base);
      break;
    }
  }
  fclose(maps);
  return base;
}

static uintptr_t find_libloader_base(void) {
  FILE *maps = fopen("/proc/self/maps", "r");
  if (!maps)
    return 0;

  char line[512];
  uintptr_t base = 0;

  while (fgets(line, sizeof(line), maps)) {
    if (strstr(line, "libloader.so") && strstr(line, "r-xp")) {
      sscanf(line, "%lx", &base);
      log_debug("Found libloader.so base: 0x%lx\\n", base);
      break;
    }
  }
  fclose(maps);
  return base;
}

// Optimized Assembly Routine
extern int fast_check_ptr(void *ptr);

typedef struct {
  uintptr_t candidate;
  int score;
  int valid_ptrs;
  int code_ptrs;
  int reasonable_stack;
} lua_state_candidate_t;

static int score_lua_state_candidate(uintptr_t addr, uintptr_t sober_base) {

  uint8_t header[64];
  int mem_fd = open("/proc/self/mem", O_RDONLY);
  if (mem_fd < 0)
    return 0;

  ssize_t r = pread(mem_fd, header, sizeof(header), addr);
  close(mem_fd);

  if (r < (ssize_t)sizeof(header))
    return 0;

  int score = 0;
  uintptr_t *ptrs = (uintptr_t *)(header + 8);

  for (int i = 0; i < 6; i++) {
    uintptr_t p = ptrs[i];

    if (fast_check_ptr((void *)p) && p > 0x10000) {
      score += 2;
    }

    if (p >= sober_base && p < sober_base + 0x800000) {
      score += 5;
    }
  }

  uintptr_t maybe_base = ptrs[1];
  uintptr_t maybe_top = ptrs[2];

  if (maybe_top > maybe_base && (maybe_top - maybe_base) < 8 * 1024 * 1024) {
    score += 10;
  }

  return score;
}

lua_State *find_lua_state(uintptr_t sober_base) {
  if (!sober_base)
    return NULL;

  // Prioritize Sober-specific static anchor
  uintptr_t static_L = sober_base + OFF_LUA_STATE_ANCHOR;
  log_debug("Checking static anchor: 0x%lx\n", static_L);

  if (sigsetjmp(g_jmp, 1) == 0) { // Safety first
    uintptr_t *L_ptr = (uintptr_t *)static_L;
    if (L_ptr[1] > L_ptr[2] && (L_ptr[1] - L_ptr[2]) < 1000000) {
      log_debug("Static anchor VALID: %p\n", (void *)static_L);
      return (lua_State *)static_L;
    }
  }
  log_debug("Static anchor invalid, falling back to full scan...\n");

  FILE *maps = fopen("/proc/self/maps", "r");
  if (!maps)
    return NULL;

  int mem_fd = open("/proc/self/mem", O_RDONLY);
  if (mem_fd < 0) {
    fclose(maps);
    return NULL;
  }

  lua_state_candidate_t best = {0, 0, 0, 0, 0};
  char line[512];

  while (fgets(line, sizeof(line), maps)) {
    uintptr_t start, end;
    char perms[5];
    int inode = 0;

    if (sscanf(line, "%lx-%lx %4s %*x %*s %d", &start, &end, perms, &inode) < 3)
      continue;

    if (perms[0] != 'r' || perms[1] != 'w' || inode != 0)
      continue;

    size_t region_size = end - start;
    if (region_size < 4096 || region_size > 100 * 1024 * 1024)
      continue;

    log_debug("Scanning region 0x%lx - 0x%lx (%zu KB)\n", start, end,
              region_size / 1024);

    uint8_t buf[4096];
    for (uintptr_t offset = 0; offset < region_size; offset += 256 * 1024) {
      ssize_t r = pread(mem_fd, buf, sizeof(buf), start + offset);
      if (r < 128)
        continue;

      for (size_t i = 0; i < (size_t)r - 64; i += 8) {
        uintptr_t candidate = start + offset + i;

        uintptr_t *ptrs = (uintptr_t *)(buf + i);

        int valid = 0, code = 0;
        for (int j = 0; j < 8; j++) {
          if (ptrs[j] > 0x10000 && ptrs[j] < 0x800000000000UL)
            valid++;
          if (ptrs[j] >= sober_base && ptrs[j] < sober_base + 0x800000)
            code++;
        }

        if (valid >= 5 && code >= 1) {
          int score = score_lua_state_candidate(candidate, sober_base);
          if (score > best.score) {
            best.candidate = candidate;
            best.score = score;
            best.valid_ptrs = valid;
            best.code_ptrs = code;
          }
        }
      }
    }
  }

  close(mem_fd);
  fclose(maps);

  if (best.score >= 15) {
    log_debug("Best Lua state candidate: 0x%lx (score=%d, valid=%d, code=%d)\n",
              best.candidate, best.score, best.valid_ptrs, best.code_ptrs);
    return (lua_State *)best.candidate;
  }

  log_debug("No good Lua state candidate found (best score: %d)\n", best.score);
  return NULL;
}

static void crash_handler(int sig) {
  if (g_in_call) {
    log_debug("CRASH in function call (signal %d)\n", sig);
    g_in_call = 0;
    siglongjmp(g_jmp, 1);
  }
}

int safe_call(void *func, lua_State *L, const char *arg) {
  if (!func || !L)
    return -1;

  struct sigaction sa, old_segv, old_bus, old_fpe;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = crash_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;

  sigaction(SIGSEGV, &sa, &old_segv);
  sigaction(SIGBUS, &sa, &old_bus);
  sigaction(SIGFPE, &sa, &old_fpe);

  g_in_call = 1;
  int result = -1;

  if (sigsetjmp(g_jmp, 1) == 0) {

    typedef void (*getglobal_t)(lua_State *, const char *);
    getglobal_t fn = (getglobal_t)func;
    fn(L, arg);
    result = 0;
    g_in_call = 0;
  }

  sigaction(SIGSEGV, &old_segv, NULL);
  sigaction(SIGBUS, &old_bus, NULL);
  sigaction(SIGFPE, &old_fpe, NULL);

  return result;
}

extern int scan_and_resolve_functions(luau_api_t *api);
extern int probe_candidate_offsets(luau_api_t *api,
                                   int (*test_func)(void *, lua_State *,
                                                    const char *));

static const uintptr_t KNOWN_OFFSETS[] = {

    0x1846a0, 0x1846c0, 0x1846e0, 0x184920, 0x184940, 0x1849b0,

    0x180dd0, 0x181c10, 0x183590, 0x183bf0,

    0x120430, 0x1239a0, 0};

int resolve_functions(luau_api_t *api) {
  if (!api || !api->sober_base) {
    return -1;
  }

  int resolved = 0;

  // Find libloader.so - this is where Luau functions actually live
  uintptr_t libloader_base = find_libloader_base();
  log_debug("Sober base: 0x%lx, libloader base: 0x%lx\n", api->sober_base,
            libloader_base);

  // Get lua_State from the scan (already done in luau_api_init)
  if (api->L) {
    log_debug("Using lua_State: %p\n", (void *)api->L);
    resolved++;
  }

  /*
   * OFFSET DISCOVERY STATUS:
   *
   * Sober's binaries are fully stripped and encrypted.
   * Automatic offset discovery failed.
   *
   * TO ENABLE EXECUTION:
  /*
   * CANDIDATE OFFSETS - January 11, 2026
   * Testing tiny functions found via live analysis
   */
  #define OFF_GETTOP_1 0x36600
  #define OFF_SETTOP_1 0x15600

  if (libloader_base) {
    log_debug("Testing tiny function candidates...\\n");
    api->gettop = (lua_gettop_t)(libloader_base + OFF_GETTOP_1);
    api->settop = (lua_settop_t)(libloader_base + OFF_SETTOP_1);
    
    if (api->gettop) { resolved++; log_debug("gettop: %p\\n", (void*)api->gettop); }
    if (api->settop) { resolved++; log_debug("settop: %p\\n", (void*)api->settop); }
  }

  log_debug("Resolved %d functions\\n", resolved);
  api->functions_resolved = resolved;
  return resolved;
}

int execute_script(luau_api_t *api, const char *script, char *output,
                   size_t output_size) {
  if (!api || !script || !output) {
    return -1;
  }

  if (!api->L) {
    snprintf(output, output_size,
             "ERROR: Lua state not found\n"
             "\n"
             "The executor could not locate the Lua VM in Sober's memory.\n"
             "Try clicking RESCAN after you're in a game.");
    return -1;
  }

  if (!api->loadbuffer) {
    snprintf(output, output_size,
             "ERROR: luaL_loadbuffer not found\n"
             "\n"
             "Sober is encrypted - automatic offset discovery failed.\n"
             "Functions resolved: %d\n"
             "Sober base: 0x%lx\n"
             "Lua state: %p\n"
             "\n"
             "Manual reverse engineering is needed to find function offsets.\n"
             "Check the debug log at /tmp/sirracha_debug.log",
             api->functions_resolved, api->sober_base, (void *)api->L);
    return -1;
  }

  if (!api->pcall) {
    snprintf(output, output_size,
             "ERROR: lua_pcall not found\n"
             "\n"
             "Cannot execute scripts without pcall function.\n"
             "Manual offset discovery required.");
    return -1;
  }

  log_debug("Executing script (%zu bytes)...\\n", strlen(script));

  struct sigaction sa, old_segv, old_bus;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = crash_handler;
  sigaction(SIGSEGV, &sa, &old_segv);
  sigaction(SIGBUS, &sa, &old_bus);

  g_in_call = 1;
  int status = -1;

  if (sigsetjmp(g_jmp, 1) == 0) {

    int top = api->gettop ? api->gettop(api->L) : 0;

    status = api->loadbuffer(api->L, script, strlen(script), "@sirracha");

    if (status != LUA_OK) {

      const char *err = "Unknown compilation error";
      if (api->tolstring) {
        err = api->tolstring(api->L, -1, NULL);
      }
      snprintf(output, output_size, "COMPILE ERROR: %s", err ? err : "null");

      if (api->settop)
        api->settop(api->L, top);
      g_in_call = 0;
      sigaction(SIGSEGV, &old_segv, NULL);
      sigaction(SIGBUS, &old_bus, NULL);
      return -1;
    }

    log_debug("Script compiled, executing...\n");

    status = api->pcall(api->L, 0, 0, 0);

    if (status != LUA_OK) {
      const char *err = "Unknown runtime error";
      if (api->tolstring) {
        err = api->tolstring(api->L, -1, NULL);
      }
      snprintf(output, output_size, "RUNTIME ERROR: %s", err ? err : "null");

      if (api->settop)
        api->settop(api->L, top);
      g_in_call = 0;
      sigaction(SIGSEGV, &old_segv, NULL);
      sigaction(SIGBUS, &old_bus, NULL);
      return -1;
    }

    snprintf(output, output_size, "✓ Script executed successfully");
    if (api->settop)
      api->settop(api->L, top);

    g_in_call = 0;
  } else {

    snprintf(output, output_size, "CRASH: Execution caused a signal");
    status = -1;
  }

  sigaction(SIGSEGV, &old_segv, NULL);
  sigaction(SIGBUS, &old_bus, NULL);

  return status;
}

int luau_api_init(luau_api_t *api) {
  memset(api, 0, sizeof(luau_api_t));

  log_debug("===========================================\n");
  log_debug("Sirracha Executor v2.0 - Full Edition\n");
  log_debug("PID: %d\n", getpid());
  log_debug("===========================================\n");

  // unlockbreaker(); // Disabled to prevent crash caused by detaching internal
  // tracers

  api->sober_base = find_sober_base();
  if (!api->sober_base) {
    log_debug("FATAL: Could not find Sober base address\n");
    return -1;
  }
  log_debug("Sober base: 0x%lx\n", api->sober_base);

  api->L = find_lua_state(api->sober_base);
  if (!api->L) {
    log_debug("WARNING: Could not find Lua state (will retry)\n");

  } else {
    log_debug("Lua state: %p\n", (void *)api->L);
  }

  int resolved = resolve_functions(api);
  log_debug("Resolved %d functions\n", resolved);

  api->initialized = 1;
  return 0;
}

static void probe_functions(void) {
  char output[4096];
  int pos = 0;

  pos += snprintf(output + pos, sizeof(output) - pos,
                  "===== SIRRACHA EXECUTOR v2.0 =====\n\n"
                  "Sober Base: 0x%lx\n"
                  "Lua State: %p\n"
                  "Functions: %d resolved\n\n",
                  g_api.sober_base, (void *)g_api.L, g_api.functions_resolved);

  pos += snprintf(output + pos, sizeof(output) - pos,
                  "Resolved Functions:\n"
                  "  getglobal:   %p\n"
                  "  gettop:      %p\n"
                  "  settop:      %p\n"
                  "  pushstring:  %p\n"
                  "  pcall:       %p\n"
                  "  loadbuffer:  %p\n"
                  "  tolstring:   %p\n\n",
                  (void *)g_api.getglobal, (void *)g_api.gettop,
                  (void *)g_api.settop, (void *)g_api.pushstring,
                  (void *)g_api.pcall, (void *)g_api.loadbuffer,
                  (void *)g_api.tolstring);

  if (g_api.L && g_api.loadbuffer && g_api.pcall) {
    pos += snprintf(output + pos, sizeof(output) - pos,
                    "STATUS: Ready to execute scripts!\n");
  } else {
    pos += snprintf(output + pos, sizeof(output) - pos,
                    "STATUS: Missing components, limited functionality\n");
  }

  write_output("%s", output);
}

void *worker_thread_func(void *arg) {
  (void)arg;

  // Brief stabilization delay
  sleep(1);

  if (luau_api_init(&g_api) < 0) {
    log_debug("Failed to initialize Luau API\n");
  }

  write_ready_signal();

  while (g_running) {

    if (access(IPC_EXEC_PATH, F_OK) == 0) {
      char *script = read_script();
      if (script && strlen(script) > 0) {
        log_debug("Received script: %s\n", script);

        if (strcmp(script, "__PROBE__") == 0) {
          probe_functions();
        } else if (strcmp(script, "__RESCAN__") == 0) {

          g_api.L = find_lua_state(g_api.sober_base);
          resolve_functions(&g_api);
          write_ready_signal();
          write_output("Rescanned. State=%p, Funcs=%d\n", (void *)g_api.L,
                       g_api.functions_resolved);
        } else if (strcmp(script, "__STRINGS__") == 0) {

          extern int scan_all_strings(luau_api_t * api);
          int found = scan_all_strings(&g_api);
          write_output("Scanned for Lua strings: found %d\n"
                       "Check /tmp/sirracha_debug.log for details",
                       found);
        } else if (strcmp(script, "__DISCOVER__") == 0) {

          extern int aggressive_function_discovery(luau_api_t * api);
          write_output("Running aggressive function discovery...\n"
                       "This may take a moment. Check debug log for results.");
          int found = aggressive_function_discovery(&g_api);
          write_output("Discovery complete: %d potential functions found.\n"
                       "See /tmp/sirracha_debug.log for details.",
                       found);
        } else if (strcmp(script, "__SAFEPROBE__") == 0) {

          extern int safe_function_discovery(luau_api_t * api);
          write_output("Running safe function discovery...\n"
                       "Scanning for function prologues in code regions...");
          int found = safe_function_discovery(&g_api);
          write_output("Safe probe complete: %d functions found.\n"
                       "Check /tmp/sirracha_debug.log for offsets.",
                       found);
        } else if (strcmp(script, "__ROBLOX__") == 0) {

          extern int find_datamodel(uintptr_t sober_base,
                                    roblox_state_t *state);
          extern int find_local_player(roblox_state_t * state);
          extern void dump_roblox_state(roblox_state_t * state);

          write_output("Testing Roblox offsets...\n");

          static roblox_state_t rstate = {0};
          int dm_result = find_datamodel(g_api.sober_base, &rstate);

          if (dm_result == 0) {
            find_local_player(&rstate);
            dump_roblox_state(&rstate);
            write_output("Roblox state found! Check debug log for details.\n"
                         "DataModel: 0x%lx, LocalPlayer: 0x%lx",
                         rstate.datamodel, rstate.local_player);
          } else {
            write_output(
                "Failed to find DataModel. Offsets may need adjustment.\n"
                "Check /tmp/sirracha_debug.log for details.");
          }
        } else if (strcmp(script, "__DUMP_V2__") == 0) {
          // Dump Sober's decrypted memory regions for reverse engineering
          write_output("Dumping Sober's decrypted regions...\n");
          log_debug("=== MEMORY DUMP REQUESTED ===\n");

          FILE *maps = fopen("/proc/self/maps", "r");
          if (!maps) {
            write_output("ERROR: Failed to read memory maps\n");
            log_debug("Failed to open /proc/self/maps\n");
          } else {
            char line[512];
            int region_count = 0;

            while (fgets(line, sizeof(line), maps)) {
              uintptr_t start, end;
              char perms[8];
              char path[512] = {0};
              int items = sscanf(line, "%lx-%lx %s %*x %*s %*s %s", &start,
                                 &end, perms, path);

              size_t size = end - start;
              int is_sober =
                  (strstr(line, "/sober") || strstr(line, "/app/bin/sober") ||
                   strstr(line, "/app/bin/lib"));
              int is_anon = (items < 4);
              int is_rx = (perms[2] == 'x');

              if (is_sober || is_rx || (is_anon && size < 100 * 1024 * 1024)) {
                if (size > 150 * 1024 * 1024)
                  continue;

                char outpath[256];
                snprintf(outpath, sizeof(outpath),
                         "/tmp/sober_dump_0x%lx_%zu_%s.bin", start, size,
                         perms);

                FILE *outfile = fopen(outpath, "wb");
                if (outfile) {
                  chmod(outpath, 0666);
                  fwrite((void *)start, 1, size, outfile);
                  fclose(outfile);
                  region_count++;
                }
              }
            }
            fclose(maps);

            // EXTRACT LIVE POINTERS FROM L
            if (g_api.L) {
              log_debug("Walking live Luau state at %p...\n", (void *)g_api.L);
              uintptr_t *ptrs = (uintptr_t *)g_api.L;
              uintptr_t l_g = ptrs[4]; // global_State* is usually at offset 32
              log_debug("Potential global_State: 0x%lx\n", l_g);

              if (l_g > 0x10000) {
                // Try to find common function patterns in the vicinity of known
                // code This will be printed to debug log
              }
            }

            log_debug("Dump complete: %d regions written\n", region_count);
            write_output("✓ Dump complete! %d regions exported.\n"
                         "Check /tmp/sober_dump_*.bin inside the container.\n\n"
                         "Use: cp /tmp/sober_dump_*.bin ~/ to analyze.",
                         region_count);
          }
        } else {

          char output[8192];
          execute_script(&g_api, script, output, sizeof(output));
          write_output("%s", output);
        }
        free(script);
      }
    }

    if (access(IPC_CMD_PATH, F_OK) == 0) {

      unlink(IPC_CMD_PATH);
    }

    // Aggressive retry logic if state is missing
    if (!g_api.L && g_api.sober_base) {
      static int retry_count = 0;
      if (++retry_count % 10 == 0) { // Retry every 1s
        log_debug("Retrying Lua state search (attempt %d)...\n",
                  retry_count / 10);

        // Wrap find_lua_state in a safe call to prevent crashes
        struct sigaction sa, old_segv;
        memset(&sa, 0, sizeof(sa));
        sa.sa_handler = crash_handler;
        sigaction(SIGSEGV, &sa, &old_segv);

        if (sigsetjmp(g_jmp, 1) == 0) {
          g_in_call = 1;
          g_api.L = find_lua_state(g_api.sober_base);
          g_in_call = 0;

          if (g_api.L) {
            log_debug("Found Lua state on retry: %p\n", (void *)g_api.L);
            resolve_functions(&g_api);
            write_ready_signal(); // Trigger UI update!
          }
        } else {
          g_in_call = 0;
          log_debug("Crash caught during state search retry\n");
        }
        sigaction(SIGSEGV, &old_segv, NULL);
      }
    }

    usleep(100000);
  }

  log_debug("Worker thread exiting\n");

  if (g_log) {
    fclose(g_log);
    g_log = NULL;
  }

  return NULL;
}

__attribute__((constructor)) void lib_init(void) {
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 4 * 1024 * 1024);

  pthread_create(&g_worker_thread, &attr, worker_thread_func, NULL);
  pthread_detach(g_worker_thread);

  pthread_attr_destroy(&attr);
}

__attribute__((destructor)) void lib_fini(void) {
  g_running = 0;
  usleep(200000);

  if (g_log) {
    fclose(g_log);
    g_log = NULL;
  }
}
